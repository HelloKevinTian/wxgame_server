'use strict';
/**
 * @tcp网络模块
 * @author tw
 */
var fs = require('fs');
var net = require('net');
var util = require('util');
var domain = require('domain');
var EventEmitter = require('events').EventEmitter;
var logger = require('ss-logger').getLogger(__filename);
var ExBuffer = require('ExBuffer');
var Handler = require('ss-handler');
var protoManager = require('../../../proto/ProtoManager');

/**
 * 网络连接器
 * @extends EventEmitter
 */
var Connector = function() {
	EventEmitter.call(this);

	this.name = null; //服务器名
	this.type = null; //服务器类型
	this.host = ''; //服务器IP
	this.port = 0; //监听端口
	this.timeout = 0; //socket超时时间
	this.isBigEndian = null; //传输数据是否为大端序
	this.use_json = true; //传输格式是否使用json

	this.handler = null; //模块句柄
	this.server = null; //服务器实例
	this.verifyMsg = null; //通讯数据包校验
	this.connection = null; //socket连接时触发模块
	this.disconnect = null; //socket出错时触发模块

	this.nologMessage = null;
};

util.inherits(Connector, EventEmitter);

/**
 * 配置服务器相关
 *
 * @param {String} config 配置文件路径
 */
Connector.prototype.configure = function(type, config) {
	if (type === 'server') {

		this.name = config.name;
		this.type = config.type;
		this.host = config.host;
		this.port = config.port;
		this.timeout = config.timeout;
		this.isBigEndian = config.big_endian;
		this.use_json = config.use_json;

		this.nologMessage = config.nolog_message; //无日志打印的消息列表

		if (config.hasOwnProperty('verifyMsg')) {
			this.verifyMsg = require(process.cwd() + config.verifyMsg).handle;
		}
		if (config.hasOwnProperty('connection')) {
			this.connection = require(process.cwd() + config.connection).handle;
		}
		if (config.hasOwnProperty('disconnect')) {
			this.disconnect = require(process.cwd() + config.disconnect).handle;
		}
	} else if (type === 'handle') {
		this.handler = new Handler(config);
	}
};

/**
 * 创建 tcp 服务器
 */
Connector.prototype.createTcpServer = function() {
	//logger.js line 141 有定制修改
	var self = this;

	self.server = net.createServer();

	self.online();
	self.onErr();
	self.limitClientNum(CONST.SERVER_MAX_PLAYER_NUM[process.game_config.server_type]);

	self.server.listen(self.port, self.host, function() {
		// logger.info('创建 tcp 服务器 host = [%s] port = [%d]', self.server.address().address, self.server.address().port);
	});

	self.server.on('connection', function(sock) {
		var d = domain.create();

		var socketId = sock.remoteAddress + ':' + sock.remotePort;

		sock.test = function() {
			logger.info('socket info：', sock.remoteAddress, sock.remotePort);
		}

		sock.sendMessage = function(data, protoName) {
			if (sock.destroyed) {
				return;
			}

			if (self.use_json) { //json
				if (typeof data !== 'string') {
					data = JSON.stringify(data);
				}

				var len = Buffer.byteLength(data);

				//写入4个字节表示本次包长
				var headBuf = new Buffer(4);
				headBuf.writeUInt32BE(len, 0);
				sock.write(headBuf);

				var bodyBuf = new Buffer(len);
				bodyBuf.write(data);
				sock.write(bodyBuf);

				if (self.nologMessage.indexOf(protoName) == -1) {
					logger.info('<<<<<< 发到客户端的数据:[uid:%s] [%s字节] %s', sock.uid, (4 + len), data);
				}
			} else { //protobuf
				var buf = protoManager.Encode(data, protoName);

				sock.write(buf);

				if (self.nologMessage.indexOf(protoName) == -1) {
					logger.info('<<<<<< 发到客户端的数据:[uid:%s] [%s字节] %s', sock.uid, buf.length, JSON.stringify(data));
				}
			}
		}

		sock.sendError = function(err, flowid) {
			if (sock.destroyed) {
				return;
			}

			var code = Number(err);
			if (isNaN(code) || err == null || err == undefined) {
				code = 10000;
			}

			if (self.use_json) {
				sock.sendMessage({
					'op': 'message_s2c_error_code',
					'code': code
				});
			} else {
				var msg = protoManager.NewMessage('s2c_error_code', {
					'tail': {
						'time': Math.floor(Date.now()),
						'flowid': flowid
					},
					'code': code
				});
				sock.sendMessage(msg, 'message_s2c_error_code');
			}
		}

		logger.info('new client connected: %s:%s', sock.remoteAddress, sock.remotePort);

		if (self.connection) {
			self.connection.call(null, sock);
		};

		onSocketErr();
		onTimeout();
		onException();
		onReceive();

		//回调中异常处理
		function onException() {
			d.on('error', function(err) {
				logger.error('未知异常：' + err.stack);
				//通知客户端出错
				// sock.end();

				var date = new Date();
				var time = util.format('%d-%d-%d-%d-%d-%d', date.getFullYear(), date.getMonth() + 1, date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds());
				var str = util.format('%s 未知异常: %s\n', time, err.stack);
				if (!fs.existsSync('./logs')) { //不存在就创建一个
					fs.mkdirSync('./logs', '0755');
				}
				fs.appendFile('logs/' + self.name + '_tcp_uncaughtException.log', str);
			});
			d.add(sock);
		}

		//接收客户端数据
		function onReceive() {
			var exBuffer = self.isBigEndian ? new ExBuffer().uint32Head() : new ExBuffer().uint32Head().littleEndian();

			//socket接收的原始数据
			sock.on('data', function(data) {
				// logger.info('>>>>> 收到原始数据：', data.length, data.toString());
				exBuffer.put(data);
			});

			//exBuffer分包处理后的数据
			exBuffer.on('data', function(buffer) {
				var args = null;
				if (self.use_json) {
					try {
						args = JSON.parse(buffer.toString());
					} catch (e) {
						args = buffer.toString();
					}
					if (self.nologMessage.indexOf(args.op) == -1) {
						logger.info('>>>>> 收到客户端数据：[uid:%s] [%s字节]', sock.uid || args.uid, buffer.length, args);
					}
				} else {
					args = protoManager.TcpDecode(buffer);

					if (!args) {
						logger.error('参数解析错误 ');
						sock.emit('c_close');
						return;
					}

					if (self.nologMessage.indexOf(args.headerMsg.protoId) == -1) {
						logger.info('>>>>> 收到客户端数据：[uid:%s] [%s字节]', args.head.uid, buffer.length + 4, args);
					}
				}

				d.run(function() {
					self.socketMessage(sock, args);
				});
			});
		}

		//socket超时处理
		function onTimeout() {
			sock.setTimeout(self.timeout);
			sock.addListener('timeout', function() {
				logger.debug('>>>>> socket timeout: ip:' + sock.remoteAddress + ', port:' + sock.remotePort);
				sock.emit('c_close');
			});
		}

		//socket错误监听
		function onSocketErr() {
			sock.on('error', function(e) {
				logger.error('>>>>> socket err: ' + e);
				sock.emit('c_close');
			});

			sock.on('close', function(had_error) {
				logger.debug('>>>>> socket on close: ', had_error);
				if (self.disconnect) {
					self.disconnect.call(null, sock, had_error);
				}
				if (!sock.destroyed) {
					sock.destroy();
				}
			});

			//新加事件，socket出错时调用 sock.emit('c_close')
			sock.on('c_close', function() {
				logger.debug('>>>>> socket on c_close');
				sock.end();
				sock.destroy();
			});
		}

	});

};

/**
 * 数据协议解析
 *
 * @param {Object} socket
 * @param {Object} args 数据包
 */
Connector.prototype.socketMessage = function(socket, args) {
	var self = this;
	var opUrl = self.use_json ? args.op : args.head.op;

	self.verifyMessage(args, function(result, data) {
		if (result) {
			return logger.error('[ %s-Server ] 数据验证未通过!', self.name);
		}

		if (self.handler) {
			self.handler.trigger(opUrl, data, socket);
		} else {
			logger.error('[ %s-Server ]收到未知请求 data[ %s ]', self.name, JSON.stringify(data));
		}
	}, socket);
};

/**
 * 数据验证
 *
 * @param {Object} args 数据包
 * @param {Function} endcb 结束回调函数
 */
Connector.prototype.verifyMessage = function(args, result, socket) {
	if (this.verifyMsg) {
		this.verifyMsg(args, result, socket);
	} else {
		result(false, args);
	}
};

/**
 * 开启服务器
 */
Connector.prototype.start = function() {
	if (this.type === 'tcp') {
		this.createTcpServer();
	} else {
		logger.error('开启服务器 类型错误! this.type = [ %s ]', this.type);
	}
};

/**
 * 显示服务器信息
 */
Connector.prototype.show = function() {
	logger.debug('创建 %s 服务器 host = [%s] port = [%d]', this.type, this.host, this.port);
};

/**
 * 显示服务器配置
 */
Connector.prototype.info = function() {
	logger.info(this);
};

/**
 * 定时器监测客户端连接数量
 */
Connector.prototype.online = function() {
	var self = this;
	setInterval(function() {
		self.server.getConnections(function(err, count) {
			if (!err) {
				logger.info('当前在线人数：' + count);
			}
		})
	}, 30 * 60 * 1000);
}

/**
 * 监听服务器报错
 */
Connector.prototype.onErr = function() {
	var self = this;
	self.server.on('error', function(e) {
		logger.error('WARNING: catch server error: ', e.code);
	});

	self.server.on('close', function() {
		logger.error('WARNING: server closed');
	});
}

/**
 * 限制客户端连接数量
 */
Connector.prototype.limitClientNum = function(n) {
	this.server.maxConnections = n;
}

/**
 * 踢人
 */
Connector.prototype.kick = function(sock) {
	sock.emit('c_close');
}

module.exports = Connector;